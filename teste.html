<!DOCTYPE html>
<html>
<head>
    <title>Teste Events iFood</title>
    <style>
        .order-event {
            padding: 10px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .CFM { background-color: #e3f2fd; }
        .DDCR { background-color: #fff3e0; }
        .log { font-family: monospace; }
    </style>
</head>
<body>
    <h3>Token: <span id="token-status">Não autenticado</span></h3>
    <div id="orders"></div>
    <pre id="log" class="log"></pre>

    <script>
        const CONFIG = {
            merchantId: '2733980',
            merchantUUID: '3a9fc83b-ffc3-43e9-aeb6-36c9e827a143',
            clientId: 'e6415912-782e-4bd9-b6ea-af48c81ae323',
            clientSecret: '137o75y57ug8fm55ubfoxlwjpl0xm25jxj18ne5mser23mbprj5nfncvfnr82utnzx73ij4h449o298370rjwpycppazsfyh2s0l',
            pollingInterval: 30000
        };

        let accessToken = null;
        const logElement = document.getElementById('log');
        const tokenStatus = document.getElementById('token-status');

        function log(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            let logMessage = `[${timestamp}] ${message}`;
            if (data) {
                logMessage += '\n' + JSON.stringify(data, null, 2);
            }
            logMessage += '\n';
            logElement.textContent += logMessage;
            console.log(message, data);
        }

        async function authenticate() {
            try {
                log('Iniciando autenticação...');
                
                const formData = new URLSearchParams();
                formData.append('grantType', 'client_credentials');
                formData.append('clientId', CONFIG.clientId);
                formData.append('clientSecret', CONFIG.clientSecret);

                const response = await fetch('/.netlify/functions/ifood-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: '/authentication/v1.0/oauth/token',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: formData.toString(),
                        isAuth: true
                    })
                });

                const responseText = await response.text();
                log('Resposta da autenticação:', responseText);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = responseText ? JSON.parse(responseText) : null;
                
                if (data && data.accessToken) {
                    accessToken = data.accessToken;
                    tokenStatus.textContent = `Autenticado (${accessToken.substring(0, 10)}...)`;
                    log('Autenticação bem sucedida', { token: `${accessToken.substring(0, 10)}...` });
                    return true;
                } else {
                    throw new Error('Token não recebido');
                }
            } catch (error) {
                log('Erro na autenticação:', error);
                tokenStatus.textContent = 'Falha na autenticação';
                return false;
            }
        }

        async function makeAuthorizedRequest(path, method = 'GET', body = null) {
            try {
                if (!accessToken) {
                    await authenticate();
                }

                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                };

                if (path.includes('events')) {
                    headers['x-polling-merchants'] = CONFIG.merchantUUID;
                }

                const requestBody = {
                    path,
                    method,
                    headers
                };

                if (body) {
                    requestBody.body = body;
                }

                log(`Enviando requisição para ${path}`, requestBody);

                const response = await fetch('/.netlify/functions/ifood-proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                const responseText = await response.text();
                log(`Resposta de ${path}:`, responseText);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return responseText ? JSON.parse(responseText) : null;
            } catch (error) {
                log('Erro na requisição:', error);
                if (error.message.includes('401')) {
                    accessToken = null;
                    tokenStatus.textContent = 'Não autenticado';
                    await authenticate();
                }
                throw error;
            }
        }

        async function processEvent(event) {
            log(`Processando evento: ${event.code}`, event);

            const orderElement = document.createElement('div');
            orderElement.className = `order-event ${event.code}`;
            orderElement.innerHTML = `
                <strong>Evento:</strong> ${event.code}<br>
                <strong>Pedido:</strong> ${event.orderId}<br>
                <strong>Data:</strong> ${new Date(event.createdAt).toLocaleString()}<br>
            `;
            document.getElementById('orders').prepend(orderElement);

            try {
                const orderDetails = await makeAuthorizedRequest(`/order/v1.0/orders/${event.orderId}`);
                if (orderDetails) {
                    log(`Detalhes do pedido:`, orderDetails);
                }
            } catch (error) {
                log(`Erro ao buscar detalhes do pedido ${event.orderId}:`, error);
            }
        }

        async function pollEvents() {
            try {
                if (!accessToken) {
                    await authenticate();
                }

                log('Buscando eventos...');
                const events = await makeAuthorizedRequest('/events/v1.0/events:polling');
                
                if (events && Array.isArray(events) && events.length > 0) {
                    log(`${events.length} eventos recebidos`, events);

                    // Ordenar eventos por data
                    events.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

                    // Processar eventos sequencialmente
                    for (const event of events) {
                        await processEvent(event);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }

                    // Acknowledgment
                    try {
                        const ackPayload = events.map(e => ({id: e.id}));
                        await makeAuthorizedRequest('/events/v1.0/events/acknowledgment', 'POST', ackPayload);
                        log('Acknowledgment enviado');
                    } catch (ackError) {
                        log('Erro no acknowledgment:', ackError);
                    }
                } else {
                    log('Nenhum evento novo');
                }
            } catch (error) {
                log('Erro no polling:', error);
            } finally {
                setTimeout(pollEvents, CONFIG.pollingInterval);
            }
        }

        async function init() {
            if (await authenticate()) {
                pollEvents();
            }
        }

        init();
    </script>
</body>
</html>
